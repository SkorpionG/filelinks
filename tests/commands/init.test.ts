import * as fs from 'fs';
import * as path from 'path';
import { initCommand } from '../../src/commands/init';
import { ROOT_CONFIG_FILE_NAME, CLI_NAME } from '../../src/constants';
import * as git from '../../src/utils/git';

// Mock chalk to avoid ESM import issues in Jest
jest.mock('chalk', () => ({
  default: {
    cyan: (str: string) => str,
    dim: (str: string) => str,
    yellow: (str: string) => str,
    green: (str: string) => str,
    bold: (str: string) => str,
  },
}));

// Mock the UI module to avoid chalk import issues in Jest
jest.mock('../../src/utils/ui', () => ({
  displayCommandHeader: jest.fn(),
  displayWarning: jest.fn(),
  displaySuccess: jest.fn(),
  displayHeader: jest.fn(),
  displayDim: jest.fn(),
  displayInstructionList: jest.fn(),
  displayList: jest.fn(),
  displayBlankLine: jest.fn(),
  displayProcessing: jest.fn(),
  displayGitRepoRequired: jest.fn(),
  displayGitRootNotFound: jest.fn(),
  displayNotAtGitRoot: jest.fn(),
}));

// Mock git utilities
jest.mock('../../src/utils/git');

describe('Init Command', () => {
  let testDir: string;
  let originalCwd: string;
  let mockExit: jest.SpyInstance;

  beforeEach(() => {
    // Save original cwd
    originalCwd = process.cwd();

    // Create a unique test directory for each test
    testDir = path.join(__dirname, 'test-init-' + Date.now());
    fs.mkdirSync(testDir, { recursive: true });

    // Change to test directory
    process.chdir(testDir);

    // Mock process.exit to prevent tests from exiting
    mockExit = jest.spyOn(process, 'exit').mockImplementation(((
      code?: string | number | null | undefined
    ) => {
      throw new Error(`process.exit called with ${code}`);
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    }) as any);

    // Mock git utilities to return test directory as git root
    (git.isInGitRepo as jest.Mock).mockReturnValue(true);
    (git.findGitRoot as jest.Mock).mockReturnValue(testDir);
    (git.isGitRoot as jest.Mock).mockReturnValue(true);
  });

  afterEach(() => {
    // Restore mocks
    mockExit.mockRestore();

    // Restore original cwd
    process.chdir(originalCwd);

    // Clean up test directory
    if (fs.existsSync(testDir)) {
      fs.rmSync(testDir, { recursive: true, force: true });
    }

    // Clear mocks
    jest.clearAllMocks();
  });

  describe('initCommand', () => {
    it('should create a root config file when none exists', async () => {
      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      expect(fs.existsSync(configPath)).toBe(true);

      const content = fs.readFileSync(configPath, 'utf-8');
      expect(content).toContain(`import { RootConfig } from '${CLI_NAME}';`);
      expect(content).toContain('const config: RootConfig = {');
      expect(content).toContain('linkFiles: [');
      expect(content).toContain('export default config;');
    });

    it('should create a config file without comments in the header', async () => {
      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      // Should not contain the old header comments
      expect(content).not.toContain('/**');
      expect(content).not.toContain('* filelinks root configuration');
      expect(content).not.toContain('* This file references all link files');
      expect(content).not.toContain('* Generated by:');
      expect(content).not.toContain('*/');
    });

    it('should create an empty config when no link files exist', async () => {
      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      expect(content).toContain('linkFiles: [');
      expect(content).toContain('],');

      // Should not contain inline comments about no link files found
      expect(content).not.toContain('// No link files found');
      expect(content).not.toContain('// Create one using:');
    });

    it('should find and include existing link files', async () => {
      // Create a link file
      const linkFilePath = path.join(testDir, 'filelinks.links.json');
      fs.writeFileSync(linkFilePath, JSON.stringify([]), 'utf-8');

      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      expect(content).toContain('id: ');
      expect(content).toContain('name: ');
      expect(content).toContain('path: ');
    });

    it('should find link files in subdirectories', async () => {
      // Create subdirectories with link files
      const srcDir = path.join(testDir, 'src');
      const componentsDir = path.join(srcDir, 'components');
      fs.mkdirSync(srcDir, { recursive: true });
      fs.mkdirSync(componentsDir, { recursive: true });

      fs.writeFileSync(path.join(srcDir, 'filelinks.links.json'), JSON.stringify([]), 'utf-8');
      fs.writeFileSync(
        path.join(componentsDir, 'filelinks.links.json'),
        JSON.stringify([]),
        'utf-8'
      );

      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      // Should contain multiple entries
      const idMatches = content.match(/id: '/g);
      expect(idMatches).not.toBeNull();
      expect(idMatches!.length).toBe(2);
    });

    it('should not overwrite existing config without --force flag', async () => {
      // Create an existing config
      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const existingContent = 'existing content';
      fs.writeFileSync(configPath, existingContent, 'utf-8');

      await initCommand({});

      const content = fs.readFileSync(configPath, 'utf-8');
      expect(content).toBe(existingContent);
    });

    it('should overwrite existing config with --force flag', async () => {
      // Create an existing config
      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const existingContent = 'existing content';
      fs.writeFileSync(configPath, existingContent, 'utf-8');

      await initCommand({ force: true });

      const content = fs.readFileSync(configPath, 'utf-8');
      expect(content).not.toBe(existingContent);
      expect(content).toContain(`import { RootConfig } from '${CLI_NAME}';`);
    });

    it('should ignore link files in node_modules', async () => {
      // Create link file in node_modules
      const nodeModulesDir = path.join(testDir, 'node_modules');
      fs.mkdirSync(nodeModulesDir, { recursive: true });
      fs.writeFileSync(
        path.join(nodeModulesDir, 'filelinks.links.json'),
        JSON.stringify([]),
        'utf-8'
      );

      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      // Should have empty linkFiles array
      expect(content).toContain('linkFiles: [');
      expect(content).toContain('],');
      // Should not contain any id entries
      expect(content).not.toContain('id: ');
    });

    it('should ignore link files in dist directory', async () => {
      // Create link file in dist
      const distDir = path.join(testDir, 'dist');
      fs.mkdirSync(distDir, { recursive: true });
      fs.writeFileSync(path.join(distDir, 'filelinks.links.json'), JSON.stringify([]), 'utf-8');

      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      // Should not contain any id entries
      expect(content).not.toContain('id: ');
    });

    it('should ignore link files in build directory', async () => {
      // Create link file in build
      const buildDir = path.join(testDir, 'build');
      fs.mkdirSync(buildDir, { recursive: true });
      fs.writeFileSync(path.join(buildDir, 'filelinks.links.json'), JSON.stringify([]), 'utf-8');

      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      // Should not contain any id entries
      expect(content).not.toContain('id: ');
    });

    it('should find all supported link file names', async () => {
      // Create multiple types of link files in different directories to avoid ID collision
      fs.writeFileSync(path.join(testDir, 'filelinks.links.json'), JSON.stringify([]), 'utf-8');

      const dir1 = path.join(testDir, 'dir1');
      fs.mkdirSync(dir1, { recursive: true });
      fs.writeFileSync(path.join(dir1, '.filelinksrc.json'), JSON.stringify([]), 'utf-8');

      const dir2 = path.join(testDir, 'dir2');
      fs.mkdirSync(dir2, { recursive: true });
      fs.writeFileSync(path.join(dir2, '.filelinksrc'), JSON.stringify([]), 'utf-8');

      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      // Should contain multiple entries (3 different files)
      const idMatches = content.match(/id: '/g);
      expect(idMatches).not.toBeNull();
      expect(idMatches!.length).toBe(3);
    });

    it('should generate relative paths for link files', async () => {
      // Create a link file in a subdirectory
      const srcDir = path.join(testDir, 'src');
      fs.mkdirSync(srcDir, { recursive: true });
      fs.writeFileSync(path.join(srcDir, 'filelinks.links.json'), JSON.stringify([]), 'utf-8');

      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      // Should contain relative path (with ./ prefix)
      expect(content).toContain("path: './src/filelinks.links.json'");
    });

    it('should generate unique IDs based on directory structure', async () => {
      // Create link files in different directories with same filename
      const dir1 = path.join(testDir, 'dir1');
      const dir2 = path.join(testDir, 'dir2');
      fs.mkdirSync(dir1, { recursive: true });
      fs.mkdirSync(dir2, { recursive: true });

      fs.writeFileSync(path.join(dir1, 'filelinks.links.json'), JSON.stringify([]), 'utf-8');
      fs.writeFileSync(path.join(dir2, 'filelinks.links.json'), JSON.stringify([]), 'utf-8');

      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      // Should contain different IDs
      expect(content).toContain("id: 'dir1'");
      expect(content).toContain("id: 'dir2'");
    });

    it('should handle link file at root directory', async () => {
      // Create a link file at root
      fs.writeFileSync(path.join(testDir, 'filelinks.links.json'), JSON.stringify([]), 'utf-8');

      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      // Should contain root entry (with ./ prefix)
      expect(content).toContain("id: 'root'");
      expect(content).toContain("path: './filelinks.links.json'");
    });

    it('should create valid TypeScript that can be imported', async () => {
      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      // Basic syntax checks
      expect(content).toContain('import');
      expect(content).toContain('export default');
      expect(content).toMatch(/linkFiles:\s*\[/);
      expect(content).toMatch(/\],\s*\};/);
    });

    it('should require git repository at root', async () => {
      // Mock to indicate not in git repo
      (git.isInGitRepo as jest.Mock).mockReturnValue(false);

      // Should throw or exit early
      await expect(async () => {
        await initCommand({});
      }).rejects.toThrow();
    });

    it('should generate properly formatted TypeScript with correct spacing', async () => {
      // Create a link file
      const linkFilePath = path.join(testDir, 'filelinks.links.json');
      fs.writeFileSync(linkFilePath, JSON.stringify([]), 'utf-8');

      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      // Check for proper indentation (2 spaces)
      expect(content).toContain('  linkFiles: [');
      expect(content).toContain('    {');
      expect(content).toContain('      id: ');
      expect(content).toContain('      name: ');
      expect(content).toContain('      path: ');
      expect(content).toContain('    }');
    });

    it('should add commas between multiple link file entries', async () => {
      // Create multiple link files
      const dir1 = path.join(testDir, 'dir1');
      const dir2 = path.join(testDir, 'dir2');
      fs.mkdirSync(dir1, { recursive: true });
      fs.mkdirSync(dir2, { recursive: true });

      fs.writeFileSync(path.join(dir1, 'filelinks.links.json'), JSON.stringify([]), 'utf-8');
      fs.writeFileSync(path.join(dir2, 'filelinks.links.json'), JSON.stringify([]), 'utf-8');

      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      // Should have commas between entries
      const closingBraces = content.match(/\s*\},/g);
      expect(closingBraces).not.toBeNull();
      // One entry should have comma, last one should not
      expect(content).toMatch(/\},\s*\n\s*\{/);
    });

    it('should not add comma after last link file entry', async () => {
      // Create a single link file
      const linkFilePath = path.join(testDir, 'filelinks.links.json');
      fs.writeFileSync(linkFilePath, JSON.stringify([]), 'utf-8');

      await initCommand({});

      const configPath = path.join(testDir, ROOT_CONFIG_FILE_NAME);
      const content = fs.readFileSync(configPath, 'utf-8');

      // Last entry should end with } not },
      expect(content).toMatch(/path: '.*',\s*\n\s*\}\s*\n\s*\],/);
    });
  });
});
